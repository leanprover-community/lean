def n._main : bool → bool :=
λ (a : bool), bool.cases_on a (id_rhs bool tt) (id_rhs bool ff)
n : bool → bool → bool → bool
n._main : bool → bool
n._main.equations._eqn_1 : n._main ff = tt
n._main.equations._eqn_2 : n._main tt = ff
n._sunfold : bool → bool → bool → bool
n.equations._eqn_1 : ∀ (a b : bool), n a b ff = tt
n.equations._eqn_2 : ∀ (a b : bool), n a b tt = ff
meta def m : bool → bool :=
λ (a : bool), bool.cases_on a (id_rhs bool tt) (id_rhs bool ff)
m : bool → bool
ff
add_defn_eqns.lean:0:0: error: failed to prove recursive application is decreasing, well founded relation
  @has_well_founded.r bool (@has_well_founded_of_has_sizeof bool bool.has_sizeof)
Possible solutions: 
  - Use 'using_well_founded' keyword in the end of your definition to specify tactics for synthesizing well founded relations and decreasing proofs.
  - The default decreasing tactic uses the 'assumption' tactic, thus hints (aka local proofs) can be provided using 'have'-expressions.
The nested exception contains the failure state for the decreasing tactic.
nested exception message:
invalid apply tactic, failed to unify
  1 < 1
with
  ?m_1 < ?m_1 + ?m_2
state:
a b : bool,
m : bool → bool
⊢ 1 < 1
add_defn_eqns.lean:0:0: error: failed to prove recursive application is decreasing, well founded relation
  @has_well_founded.r bool (@has_well_founded_of_has_sizeof bool bool.has_sizeof)
Possible solutions: 
  - Use 'using_well_founded' keyword in the end of your definition to specify tactics for synthesizing well founded relations and decreasing proofs.
  - The default decreasing tactic uses the 'assumption' tactic, thus hints (aka local proofs) can be provided using 'have'-expressions.
The nested exception contains the failure state for the decreasing tactic.
nested exception message:
invalid apply tactic, failed to unify
  1 < 1
with
  ?m_1 < ?m_1 + ?m_2
state:
a b : bool,
m : bool → bool
⊢ 1 < 1
add_defn_eqns.lean:0:0: error: non-exhaustive match, the following cases are missing:
mm ff
mm tt
add_defn_eqns.lean:0:0: warning: declaration 'mm' uses sorry
def mm._main : bool → bool :=
λ (a : bool), bool.cases_on a ⁇ ⁇
def plus' : ℕ → ℕ → ℕ → ℕ :=
λ (a b : ℕ), plus'._main b
plus' : ℕ → ℕ → ℕ → ℕ
plus'._main : ℕ → ℕ → ℕ
plus'._main._meta_aux : ℕ → ℕ → ℕ
plus'._main.equations._eqn_1 : ∀ (b : ℕ), plus'._main b 0 = b
plus'._main.equations._eqn_2 : ∀ (b x : ℕ), plus'._main b (nat.succ x) = plus'._main b x
plus'._sunfold : ℕ → ℕ → ℕ → ℕ
plus'.equations._eqn_1 : ∀ (a b : ℕ), plus' a b 0 = b
plus'.equations._eqn_2 : ∀ (a b x : ℕ), plus' a b (nat.succ x) = plus' a b x
