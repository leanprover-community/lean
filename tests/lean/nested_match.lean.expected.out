nested_match.lean:7:13: error: failed to prove recursive application is decreasing, well founded relation
  @has_well_founded.r ℕ (@has_well_founded_of_has_sizeof ℕ nat.has_sizeof)
Possible solutions: 
  - Use 'using_well_founded' keyword in the end of your definition to specify tactics for synthesizing well founded relations and decreasing proofs.
  - The default decreasing tactic uses the 'assumption' tactic, thus hints (aka local proofs) can be provided using 'have'-expressions.
The nested exception contains the failure state for the decreasing tactic.
nested exception message:
assumption tactic failed
state:
f : ℕ → ℕ,
f : Π (_x : ℕ), (Π (_y : ℕ), has_well_founded.r _y _x → ℕ) → ℕ,
n : ℕ,
_F : Π (_y : ℕ), has_well_founded.r _y n → ℕ,
m : ℕ
⊢ has_well_founded.r m n
nested_match.lean:25:7: error: failed to prove recursive application is decreasing, well founded relation
  @has_well_founded.r (psum ℕ ℕ)
    (@has_well_founded_of_has_sizeof (psum ℕ ℕ) (@psum.has_sizeof_alt ℕ ℕ nat.has_sizeof nat.has_sizeof))
Possible solutions: 
  - Use 'using_well_founded' keyword in the end of your definition to specify tactics for synthesizing well founded relations and decreasing proofs.
  - The default decreasing tactic uses the 'assumption' tactic, thus hints (aka local proofs) can be provided using 'have'-expressions.
The nested exception contains the failure state for the decreasing tactic.
nested exception message:
assumption tactic failed
state:
f.g._mutual : Π (_x : psum ℕ ℕ), _x.cases_on (λ (_s : ℕ), ℕ) (λ (_s : ℕ), ℕ),
f.g._mutual :
  Π (_x : psum ℕ ℕ),
    (Π (_y : psum ℕ ℕ), has_well_founded.r _y _x → _y.cases_on (λ (_s : ℕ), ℕ) (λ (_s : ℕ), ℕ)) →
    _x.cases_on (λ (_s : ℕ), ℕ) (λ (_s : ℕ), ℕ),
n : ℕ,
_F :
  Π (_y : psum ℕ ℕ), has_well_founded.r _y (psum.inl n) → _y.cases_on (λ (_s : ℕ), ℕ) (λ (_s : ℕ), ℕ)
⊢ has_well_founded.r (psum.inr n) (psum.inl n)
